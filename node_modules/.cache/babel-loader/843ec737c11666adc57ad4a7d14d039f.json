{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialState = exports.addComponentsToState = exports[\"default\"] = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _immutable = require(\"immutable\");\n\nvar _lodash = require(\"lodash\");\n\nvar _makeUnique = _interopRequireDefault(require(\"../../utils/makeUnique\"));\n\nvar _retrieveComponentsFromSchema = _interopRequireDefault(require(\"./utils/retrieveComponentsFromSchema\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar initialState = (0, _immutable.fromJS)({\n  components: {},\n  contentTypes: {},\n  initialComponents: {},\n  initialContentTypes: {},\n  initialData: {},\n  modifiedData: {},\n  reservedNames: {},\n  isLoading: true,\n  isLoadingForDataToBeSet: true\n});\nexports.initialState = initialState;\nvar ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];\n\nvar getOppositeNature = function getOppositeNature(originalNature) {\n  if (originalNature === 'manyToOne') {\n    return 'oneToMany';\n  }\n\n  if (originalNature === 'oneToMany') {\n    return 'manyToOne';\n  }\n\n  return originalNature;\n};\n\nvar addComponentsToState = function addComponentsToState(state, componentToAddUid, objToUpdate) {\n  var newObj = objToUpdate;\n  var componentToAdd = state.getIn(['components', componentToAddUid]);\n  var isTemporaryComponent = componentToAdd.get('isTemporary');\n  var componentToAddSchema = componentToAdd.getIn(['schema', 'attributes']);\n  var hasComponentAlreadyBeenAdded = state.getIn(['modifiedData', 'components', componentToAddUid]) !== undefined; // created components are already in the modifiedData.components\n  // We don't add them because all modifications will be lost\n\n  if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {\n    return newObj;\n  } // Add the added components to the modifiedData.compontnes\n\n\n  newObj = newObj.set(componentToAddUid, componentToAdd);\n  var nestedComponents = (0, _retrieveComponentsFromSchema[\"default\"])(componentToAddSchema.toJS(), state.get('components').toJS()); // We need to add the nested components to the modifiedData.components as well\n\n  nestedComponents.forEach(function (componentUid) {\n    var isTemporary = state.getIn(['components', componentUid, 'isTemporary']) || false;\n    var hasNestedComponentAlreadyBeenAdded = state.getIn(['modifiedData', 'components', componentUid]) !== undefined; // Same logic here otherwise we will lose the modifications added to the components\n\n    if (!isTemporary && !hasNestedComponentAlreadyBeenAdded) {\n      newObj = newObj.set(componentUid, state.getIn(['components', componentUid]));\n    }\n  });\n  return newObj;\n};\n\nexports.addComponentsToState = addComponentsToState;\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'ADD_ATTRIBUTE':\n      {\n        var _action$attributeToSe = action.attributeToSet,\n            name = _action$attributeToSe.name,\n            rest = (0, _objectWithoutProperties2[\"default\"])(_action$attributeToSe, [\"name\"]),\n            forTarget = action.forTarget,\n            targetUid = action.targetUid;\n        delete rest.createComponent;\n        var pathToDataToEdit = ['component', 'contentType'].includes(forTarget) ? [forTarget] : [forTarget, targetUid];\n        return state.updateIn(['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes', name]), function () {\n          return (0, _immutable.fromJS)(rest);\n        }).updateIn(['modifiedData'].concat(pathToDataToEdit, ['schema', 'attributes']), function (obj) {\n          var type = (0, _lodash.get)(rest, 'type', 'relation');\n          var target = (0, _lodash.get)(rest, 'target', null);\n          var nature = (0, _lodash.get)(rest, 'nature', null);\n          var currentUid = state.getIn(['modifiedData'].concat(pathToDataToEdit, ['uid'])); // When the user in creating a relation with the same content type we need to create another attribute\n          // that is the opposite of the created one\n\n          if (type === 'relation' && nature !== 'oneWay' && nature !== 'manyWay' && target === currentUid) {\n            var oppositeAttribute = {\n              nature: getOppositeNature(nature),\n              target: target,\n              unique: rest.unique,\n              // Leave this if we allow the required on the relation\n              // required: rest.required,\n              dominant: nature === 'manyToMany' ? !rest.dominant : null,\n              targetAttribute: name,\n              columnName: rest.targetColumnName,\n              targetColumnName: rest.columnName\n            };\n            return obj.update(rest.targetAttribute, function () {\n              return (0, _immutable.fromJS)(oppositeAttribute);\n            });\n          }\n\n          return obj;\n        }).updateIn(['modifiedData', 'components'], function (existingCompos) {\n          if (action.shouldAddComponentToData) {\n            return addComponentsToState(state, rest.component, existingCompos);\n          }\n\n          return existingCompos;\n        });\n      }\n\n    case 'ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE':\n      {\n        var dynamicZoneTarget = action.dynamicZoneTarget,\n            componentsToAdd = action.componentsToAdd;\n        return state.updateIn(['modifiedData', 'contentType', 'schema', 'attributes', dynamicZoneTarget, 'components'], function (list) {\n          return list.concat(componentsToAdd);\n        });\n      }\n\n    case 'CANCEL_CHANGES':\n      {\n        return state.update('modifiedData', function () {\n          return state.get('initialData');\n        }).update('components', function () {\n          return state.get('initialComponents');\n        });\n      }\n\n    case 'CHANGE_DYNAMIC_ZONE_COMPONENTS':\n      {\n        var _dynamicZoneTarget = action.dynamicZoneTarget,\n            newComponents = action.newComponents;\n        return state.updateIn(['modifiedData', 'contentType', 'schema', 'attributes', _dynamicZoneTarget, 'components'], function (list) {\n          return (0, _immutable.fromJS)((0, _makeUnique[\"default\"])([].concat((0, _toConsumableArray2[\"default\"])(list.toJS()), (0, _toConsumableArray2[\"default\"])(newComponents))));\n        }).updateIn(['modifiedData', 'components'], function (old) {\n          var componentsSchema = newComponents.reduce(function (acc, current) {\n            return addComponentsToState(state, current, acc);\n          }, old);\n          return componentsSchema;\n        });\n      }\n\n    case 'CREATE_SCHEMA':\n      {\n        var newSchema = {\n          uid: action.uid,\n          isTemporary: true,\n          schema: _objectSpread(_objectSpread({}, action.data), {}, {\n            attributes: {}\n          })\n        };\n        return state.updateIn(['contentTypes', action.uid], function () {\n          return (0, _immutable.fromJS)(newSchema);\n        });\n      }\n\n    case 'CREATE_COMPONENT_SCHEMA':\n      {\n        var _newSchema = {\n          uid: action.uid,\n          isTemporary: true,\n          category: action.componentCategory,\n          schema: _objectSpread(_objectSpread({}, action.data), {}, {\n            attributes: {}\n          })\n        };\n\n        if (action.shouldAddComponentToData) {\n          return state.updateIn(['components', action.uid], function () {\n            return (0, _immutable.fromJS)(_newSchema);\n          }).updateIn(['modifiedData', 'components', action.uid], function () {\n            return (0, _immutable.fromJS)(_newSchema);\n          });\n        }\n\n        return state.updateIn(['components', action.uid], function () {\n          return (0, _immutable.fromJS)(_newSchema);\n        });\n      }\n\n    case 'DELETE_NOT_SAVED_TYPE':\n      {\n        // Doing so will also reset the modified and the initial data\n        return state.update('contentTypes', function () {\n          return state.get('initialContentTypes');\n        }).update('components', function () {\n          return state.get('initialComponents');\n        });\n      }\n\n    case 'EDIT_ATTRIBUTE':\n      {\n        var _action$attributeToSe2 = action.attributeToSet,\n            _name = _action$attributeToSe2.name,\n            _rest = (0, _objectWithoutProperties2[\"default\"])(_action$attributeToSe2, [\"name\"]),\n            _forTarget = action.forTarget,\n            _targetUid = action.targetUid,\n            initialAttribute = action.initialAttribute;\n\n        var newState = state;\n        var initialAttributeName = (0, _lodash.get)(initialAttribute, ['name'], '');\n\n        var _pathToDataToEdit = ['component', 'contentType'].includes(_forTarget) ? [_forTarget] : [_forTarget, _targetUid];\n\n        return newState.updateIn(['modifiedData'].concat(_pathToDataToEdit, ['schema']), function (obj) {\n          var oppositeAttributeNameToRemove = null;\n          var oppositeAttributeNameToUpdate = null;\n          var oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n          var oppositeAttributeToCreate = null;\n          var newObj = (0, _immutable.OrderedMap)(obj.get('attributes').keySeq().reduce(function (acc, current) {\n            var isEditingCurrentAttribute = current === initialAttributeName;\n\n            if (isEditingCurrentAttribute) {\n              var currentUid = state.getIn(['modifiedData'].concat(_pathToDataToEdit, ['uid']));\n              var isEditingRelation = (0, _lodash.has)(initialAttribute, 'nature');\n              var didChangeTargetRelation = initialAttribute.target !== _rest.target;\n              var didCreateInternalRelation = _rest.target === currentUid;\n              var nature = _rest.nature;\n              var initialNature = initialAttribute.nature;\n              var hadInternalRelation = initialAttribute.target === currentUid;\n              var didChangeRelationNature = initialAttribute.nature !== nature;\n              var shouldRemoveOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && !didCreateInternalRelation && hadInternalRelation && isEditingRelation;\n              var shouldRemoveOppositeAttributeBecauseOfNatureChange = didChangeRelationNature && hadInternalRelation && ['oneWay', 'manyWay'].includes(nature) && isEditingRelation;\n              var shouldUpdateOppositeAttributeBecauseOfNatureChange = !ONE_SIDE_RELATIONS.includes(initialNature) && !ONE_SIDE_RELATIONS.includes(nature) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;\n              var shouldCreateOppositeAttributeBecauseOfNatureChange = ONE_SIDE_RELATIONS.includes(initialNature) && !ONE_SIDE_RELATIONS.includes(nature) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;\n              var shouldCreateOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && didCreateInternalRelation && !ONE_SIDE_RELATIONS.includes(nature); // Update the opposite attribute name so it is removed at the end of the loop\n\n              if (shouldRemoveOppositeAttributeBecauseOfTargetChange || shouldRemoveOppositeAttributeBecauseOfNatureChange) {\n                oppositeAttributeNameToRemove = initialAttribute.targetAttribute;\n              } // Set the opposite attribute that will be updated when the loop attribute matches the name\n\n\n              if (shouldUpdateOppositeAttributeBecauseOfNatureChange || shouldCreateOppositeAttributeBecauseOfNatureChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {\n                oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;\n                oppositeAttributeNameToCreateBecauseOfNatureChange = _rest.targetAttribute;\n                oppositeAttributeToCreate = {\n                  nature: getOppositeNature(_rest.nature),\n                  target: _rest.target,\n                  unique: _rest.unique,\n                  // Leave this if we allow the required on the relation\n                  // required: rest.required,\n                  dominant: _rest.nature === 'manyToMany' ? !_rest.dominant : null,\n                  targetAttribute: _name,\n                  columnName: _rest.targetColumnName,\n                  targetColumnName: _rest.columnName\n                }; // First update the current attribute with the value\n\n                acc[_name] = (0, _immutable.fromJS)(_rest); // Then (if needed) create the opposite attribute the case is changing the relation from\n                // We do it here so keep the order of the attributes\n                // oneWay || manyWay to something another relation\n\n                if (shouldCreateOppositeAttributeBecauseOfNatureChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {\n                  acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = (0, _immutable.fromJS)(oppositeAttributeToCreate);\n                  oppositeAttributeToCreate = null;\n                  oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n                }\n\n                return acc;\n              }\n\n              acc[_name] = (0, _immutable.fromJS)(_rest);\n            } else if (current === oppositeAttributeNameToUpdate) {\n              acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = (0, _immutable.fromJS)(oppositeAttributeToCreate);\n            } else {\n              acc[current] = obj.getIn(['attributes', current]);\n            }\n\n            return acc;\n          }, {}));\n          var updatedObj; // Remove the opposite attribute\n\n          if (oppositeAttributeNameToRemove !== null) {\n            updatedObj = newObj.remove(oppositeAttributeNameToRemove);\n          } else {\n            updatedObj = newObj;\n          }\n\n          return obj.set('attributes', updatedObj);\n        });\n      }\n\n    case 'GET_DATA_SUCCEEDED':\n      {\n        return state.update('components', function () {\n          return (0, _immutable.fromJS)(action.components);\n        }).update('initialComponents', function () {\n          return (0, _immutable.fromJS)(action.components);\n        }).update('initialContentTypes', function () {\n          return (0, _immutable.fromJS)(action.contentTypes);\n        }).update('contentTypes', function () {\n          return (0, _immutable.fromJS)(action.contentTypes);\n        }).update('reservedNames', function () {\n          return (0, _immutable.fromJS)(action.reservedNames);\n        }).update('isLoading', function () {\n          return false;\n        });\n      }\n\n    case 'RELOAD_PLUGIN':\n      return initialState;\n\n    case 'REMOVE_FIELD_FROM_DISPLAYED_COMPONENT':\n      {\n        var attributeToRemoveName = action.attributeToRemoveName,\n            componentUid = action.componentUid;\n        return state.removeIn(['modifiedData', 'components', componentUid, 'schema', 'attributes', attributeToRemoveName]);\n      }\n\n    case 'REMOVE_COMPONENT_FROM_DYNAMIC_ZONE':\n      return state.removeIn(['modifiedData', 'contentType', 'schema', 'attributes', action.dzName, 'components', action.componentToRemoveIndex]);\n\n    case 'REMOVE_FIELD':\n      {\n        var mainDataKey = action.mainDataKey,\n            _attributeToRemoveName = action.attributeToRemoveName;\n        var pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];\n        var pathToAttributeToRemove = [].concat(pathToAttributes, [_attributeToRemoveName]);\n        var attributeToRemoveData = state.getIn(pathToAttributeToRemove);\n        var isRemovingRelationAttribute = attributeToRemoveData.get('nature') !== undefined; // Only content types can have relations with themselves since\n        // components can only have oneWay or manyWay relations\n\n        var canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';\n\n        if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {\n          var _attributeToRemoveDat = attributeToRemoveData.toJS(),\n              target = _attributeToRemoveDat.target,\n              nature = _attributeToRemoveDat.nature,\n              targetAttribute = _attributeToRemoveDat.targetAttribute;\n\n          var uid = state.getIn(['modifiedData', 'contentType', 'uid']);\n          var shouldRemoveOppositeAttribute = target === uid && !ONE_SIDE_RELATIONS.includes(nature);\n\n          if (shouldRemoveOppositeAttribute) {\n            return state.removeIn(pathToAttributeToRemove).removeIn([].concat(pathToAttributes, [targetAttribute]));\n          }\n        }\n\n        return state.removeIn(pathToAttributeToRemove).updateIn([].concat(pathToAttributes), function (attributes) {\n          return attributes.keySeq().reduce(function (acc, current) {\n            if (acc.getIn([current, 'targetField']) === _attributeToRemoveName) {\n              return acc.removeIn([current, 'targetField']);\n            }\n\n            return acc;\n          }, attributes);\n        });\n      }\n\n    case 'SET_MODIFIED_DATA':\n      {\n        var _newState = state.update('isLoadingForDataToBeSet', function () {\n          return false;\n        }).update('initialData', function () {\n          return (0, _immutable.fromJS)(action.schemaToSet);\n        }).update('modifiedData', function () {\n          return (0, _immutable.fromJS)(action.schemaToSet);\n        }); // Reset the state with the initial data\n        // All created components and content types will be lost\n\n\n        if (!action.hasJustCreatedSchema) {\n          _newState = _newState.update('components', function () {\n            return state.get('initialComponents');\n          }).update('contentTypes', function () {\n            return state.get('initialContentTypes');\n          });\n        }\n\n        return _newState;\n      }\n\n    case 'UPDATE_SCHEMA':\n      {\n        var _action$data = action.data,\n            _name2 = _action$data.name,\n            collectionName = _action$data.collectionName,\n            category = _action$data.category,\n            icon = _action$data.icon,\n            kind = _action$data.kind,\n            schemaType = action.schemaType,\n            _uid = action.uid;\n\n        var _newState2 = state.updateIn(['modifiedData', schemaType], function (obj) {\n          var updatedObj = obj.updateIn(['schema', 'name'], function () {\n            return _name2;\n          }).updateIn(['schema', 'collectionName'], function () {\n            return collectionName;\n          });\n\n          if (action.schemaType === 'component') {\n            updatedObj = updatedObj.update('category', function () {\n              return category;\n            }).updateIn(['schema', 'icon'], function () {\n              return icon;\n            });\n          }\n\n          if (action.schemaType === 'contentType') {\n            updatedObj = updatedObj.updateIn(['schema', 'kind'], function () {\n              return kind;\n            });\n          }\n\n          return updatedObj;\n        });\n\n        if (schemaType === 'component') {\n          _newState2 = _newState2.updateIn(['components'], function (obj) {\n            return obj.update(_uid, function () {\n              return _newState2.getIn(['modifiedData', 'component']);\n            });\n          });\n        }\n\n        return _newState2;\n      }\n\n    default:\n      return state;\n  }\n};\n\nvar _default = reducer;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["D:/webstorm_projects/redcat_backend/.cache/plugins/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/reducer.js"],"names":["initialState","components","contentTypes","initialComponents","initialContentTypes","initialData","modifiedData","reservedNames","isLoading","isLoadingForDataToBeSet","ONE_SIDE_RELATIONS","getOppositeNature","originalNature","addComponentsToState","state","componentToAddUid","objToUpdate","newObj","componentToAdd","getIn","isTemporaryComponent","get","componentToAddSchema","hasComponentAlreadyBeenAdded","undefined","set","nestedComponents","toJS","forEach","componentUid","isTemporary","hasNestedComponentAlreadyBeenAdded","reducer","action","type","attributeToSet","name","rest","forTarget","targetUid","createComponent","pathToDataToEdit","includes","updateIn","obj","target","nature","currentUid","oppositeAttribute","unique","dominant","targetAttribute","columnName","targetColumnName","update","existingCompos","shouldAddComponentToData","component","dynamicZoneTarget","componentsToAdd","list","concat","newComponents","old","componentsSchema","reduce","acc","current","newSchema","uid","schema","data","attributes","category","componentCategory","initialAttribute","newState","initialAttributeName","oppositeAttributeNameToRemove","oppositeAttributeNameToUpdate","oppositeAttributeNameToCreateBecauseOfNatureChange","oppositeAttributeToCreate","keySeq","isEditingCurrentAttribute","isEditingRelation","didChangeTargetRelation","didCreateInternalRelation","initialNature","hadInternalRelation","didChangeRelationNature","shouldRemoveOppositeAttributeBecauseOfTargetChange","shouldRemoveOppositeAttributeBecauseOfNatureChange","shouldUpdateOppositeAttributeBecauseOfNatureChange","shouldCreateOppositeAttributeBecauseOfNatureChange","shouldCreateOppositeAttributeBecauseOfTargetChange","updatedObj","remove","attributeToRemoveName","removeIn","dzName","componentToRemoveIndex","mainDataKey","pathToAttributes","pathToAttributeToRemove","attributeToRemoveData","isRemovingRelationAttribute","canTheAttributeToRemoveHaveARelationWithItself","shouldRemoveOppositeAttribute","schemaToSet","hasJustCreatedSchema","collectionName","icon","kind","schemaType"],"mappings":";;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;AAEA,IAAMA,YAAY,GAAG,uBAAO;AAC1BC,EAAAA,UAAU,EAAE,EADc;AAE1BC,EAAAA,YAAY,EAAE,EAFY;AAG1BC,EAAAA,iBAAiB,EAAE,EAHO;AAI1BC,EAAAA,mBAAmB,EAAE,EAJK;AAK1BC,EAAAA,WAAW,EAAE,EALa;AAM1BC,EAAAA,YAAY,EAAE,EANY;AAO1BC,EAAAA,aAAa,EAAE,EAPW;AAQ1BC,EAAAA,SAAS,EAAE,IARe;AAS1BC,EAAAA,uBAAuB,EAAE;AATC,CAAP,CAArB;;AAYA,IAAMC,kBAAkB,GAAG,CAAC,QAAD,EAAW,SAAX,CAA3B;;AAEA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAC,cAAc,EAAI;AAC1C,MAAIA,cAAc,KAAK,WAAvB,EAAoC;AAClC,WAAO,WAAP;AACD;;AAED,MAAIA,cAAc,KAAK,WAAvB,EAAoC;AAClC,WAAO,WAAP;AACD;;AAED,SAAOA,cAAP;AACD,CAVD;;AAYA,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,KAAD,EAAQC,iBAAR,EAA2BC,WAA3B,EAA2C;AACtE,MAAIC,MAAM,GAAGD,WAAb;AACA,MAAME,cAAc,GAAGJ,KAAK,CAACK,KAAN,CAAY,CAAC,YAAD,EAAeJ,iBAAf,CAAZ,CAAvB;AACA,MAAMK,oBAAoB,GAAGF,cAAc,CAACG,GAAf,CAAmB,aAAnB,CAA7B;AACA,MAAMC,oBAAoB,GAAGJ,cAAc,CAACC,KAAf,CAAqB,CAAC,QAAD,EAAW,YAAX,CAArB,CAA7B;AACA,MAAMI,4BAA4B,GAChCT,KAAK,CAACK,KAAN,CAAY,CAAC,cAAD,EAAiB,YAAjB,EAA+BJ,iBAA/B,CAAZ,MAAmES,SADrE,CALsE,CAQtE;AACA;;AACA,MAAIJ,oBAAoB,IAAIG,4BAA5B,EAA0D;AACxD,WAAON,MAAP;AACD,GAZqE,CActE;;;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACQ,GAAP,CAAWV,iBAAX,EAA8BG,cAA9B,CAAT;AACA,MAAMQ,gBAAgB,GAAG,8CACvBJ,oBAAoB,CAACK,IAArB,EADuB,EAEvBb,KAAK,CAACO,GAAN,CAAU,YAAV,EAAwBM,IAAxB,EAFuB,CAAzB,CAhBsE,CAqBtE;;AACAD,EAAAA,gBAAgB,CAACE,OAAjB,CAAyB,UAAAC,YAAY,EAAI;AACvC,QAAMC,WAAW,GAAGhB,KAAK,CAACK,KAAN,CAAY,CAAC,YAAD,EAAeU,YAAf,EAA6B,aAA7B,CAAZ,KAA4D,KAAhF;AACA,QAAME,kCAAkC,GACtCjB,KAAK,CAACK,KAAN,CAAY,CAAC,cAAD,EAAiB,YAAjB,EAA+BU,YAA/B,CAAZ,MAA8DL,SADhE,CAFuC,CAKvC;;AACA,QAAI,CAACM,WAAD,IAAgB,CAACC,kCAArB,EAAyD;AACvDd,MAAAA,MAAM,GAAGA,MAAM,CAACQ,GAAP,CAAWI,YAAX,EAAyBf,KAAK,CAACK,KAAN,CAAY,CAAC,YAAD,EAAeU,YAAf,CAAZ,CAAzB,CAAT;AACD;AACF,GATD;AAWA,SAAOZ,MAAP;AACD,CAlCD;;;;AAoCA,IAAMe,OAAO,GAAG,SAAVA,OAAU,CAAClB,KAAD,EAAQmB,MAAR,EAAmB;AACjC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,eAAL;AAAsB;AAAA,oCAKhBD,MALgB,CAElBE,cAFkB;AAAA,YAEAC,IAFA,yBAEAA,IAFA;AAAA,YAESC,IAFT;AAAA,YAGlBC,SAHkB,GAKhBL,MALgB,CAGlBK,SAHkB;AAAA,YAIlBC,SAJkB,GAKhBN,MALgB,CAIlBM,SAJkB;AAMpB,eAAOF,IAAI,CAACG,eAAZ;AAEA,YAAMC,gBAAgB,GAAG,CAAC,WAAD,EAAc,aAAd,EAA6BC,QAA7B,CAAsCJ,SAAtC,IACrB,CAACA,SAAD,CADqB,GAErB,CAACA,SAAD,EAAYC,SAAZ,CAFJ;AAIA,eAAOzB,KAAK,CACT6B,QADI,EACM,cADN,SACyBF,gBADzB,GAC2C,QAD3C,EACqD,YADrD,EACmEL,IADnE,IAC0E,YAAM;AACnF,iBAAO,uBAAOC,IAAP,CAAP;AACD,SAHI,EAIJM,QAJI,EAIM,cAJN,SAIyBF,gBAJzB,GAI2C,QAJ3C,EAIqD,YAJrD,IAIoE,UAAAG,GAAG,EAAI;AAC9E,cAAMV,IAAI,GAAG,iBAAIG,IAAJ,EAAU,MAAV,EAAkB,UAAlB,CAAb;AACA,cAAMQ,MAAM,GAAG,iBAAIR,IAAJ,EAAU,QAAV,EAAoB,IAApB,CAAf;AACA,cAAMS,MAAM,GAAG,iBAAIT,IAAJ,EAAU,QAAV,EAAoB,IAApB,CAAf;AACA,cAAMU,UAAU,GAAGjC,KAAK,CAACK,KAAN,EAAa,cAAb,SAAgCsB,gBAAhC,GAAkD,KAAlD,GAAnB,CAJ8E,CAM9E;AACA;;AACA,cACEP,IAAI,KAAK,UAAT,IACAY,MAAM,KAAK,QADX,IAEAA,MAAM,KAAK,SAFX,IAGAD,MAAM,KAAKE,UAJb,EAKE;AACA,gBAAMC,iBAAiB,GAAG;AACxBF,cAAAA,MAAM,EAAEnC,iBAAiB,CAACmC,MAAD,CADD;AAExBD,cAAAA,MAAM,EAANA,MAFwB;AAGxBI,cAAAA,MAAM,EAAEZ,IAAI,CAACY,MAHW;AAIxB;AACA;AACAC,cAAAA,QAAQ,EAAEJ,MAAM,KAAK,YAAX,GAA0B,CAACT,IAAI,CAACa,QAAhC,GAA2C,IAN7B;AAOxBC,cAAAA,eAAe,EAAEf,IAPO;AAQxBgB,cAAAA,UAAU,EAAEf,IAAI,CAACgB,gBARO;AASxBA,cAAAA,gBAAgB,EAAEhB,IAAI,CAACe;AATC,aAA1B;AAYA,mBAAOR,GAAG,CAACU,MAAJ,CAAWjB,IAAI,CAACc,eAAhB,EAAiC,YAAM;AAC5C,qBAAO,uBAAOH,iBAAP,CAAP;AACD,aAFM,CAAP;AAGD;;AAED,iBAAOJ,GAAP;AACD,SApCI,EAqCJD,QArCI,CAqCK,CAAC,cAAD,EAAiB,YAAjB,CArCL,EAqCqC,UAAAY,cAAc,EAAI;AAC1D,cAAItB,MAAM,CAACuB,wBAAX,EAAqC;AACnC,mBAAO3C,oBAAoB,CAACC,KAAD,EAAQuB,IAAI,CAACoB,SAAb,EAAwBF,cAAxB,CAA3B;AACD;;AAED,iBAAOA,cAAP;AACD,SA3CI,CAAP;AA4CD;;AACD,SAAK,uCAAL;AAA8C;AAAA,YACpCG,iBADoC,GACGzB,MADH,CACpCyB,iBADoC;AAAA,YACjBC,eADiB,GACG1B,MADH,CACjB0B,eADiB;AAG5C,eAAO7C,KAAK,CAAC6B,QAAN,CACL,CAAC,cAAD,EAAiB,aAAjB,EAAgC,QAAhC,EAA0C,YAA1C,EAAwDe,iBAAxD,EAA2E,YAA3E,CADK,EAEL,UAAAE,IAAI,EAAI;AACN,iBAAOA,IAAI,CAACC,MAAL,CAAYF,eAAZ,CAAP;AACD,SAJI,CAAP;AAMD;;AACD,SAAK,gBAAL;AAAuB;AACrB,eAAO7C,KAAK,CACTwC,MADI,CACG,cADH,EACmB;AAAA,iBAAMxC,KAAK,CAACO,GAAN,CAAU,aAAV,CAAN;AAAA,SADnB,EAEJiC,MAFI,CAEG,YAFH,EAEiB;AAAA,iBAAMxC,KAAK,CAACO,GAAN,CAAU,mBAAV,CAAN;AAAA,SAFjB,CAAP;AAGD;;AACD,SAAK,gCAAL;AAAuC;AAAA,YAC7BqC,kBAD6B,GACQzB,MADR,CAC7ByB,iBAD6B;AAAA,YACVI,aADU,GACQ7B,MADR,CACV6B,aADU;AAGrC,eAAOhD,KAAK,CACT6B,QADI,CAEH,CAAC,cAAD,EAAiB,aAAjB,EAAgC,QAAhC,EAA0C,YAA1C,EAAwDe,kBAAxD,EAA2E,YAA3E,CAFG,EAGH,UAAAE,IAAI,EAAI;AACN,iBAAO,uBAAO,0EAAeA,IAAI,CAACjC,IAAL,EAAf,uCAA+BmC,aAA/B,GAAP,CAAP;AACD,SALE,EAOJnB,QAPI,CAOK,CAAC,cAAD,EAAiB,YAAjB,CAPL,EAOqC,UAAAoB,GAAG,EAAI;AAC/C,cAAMC,gBAAgB,GAAGF,aAAa,CAACG,MAAd,CAAqB,UAACC,GAAD,EAAMC,OAAN,EAAkB;AAC9D,mBAAOtD,oBAAoB,CAACC,KAAD,EAAQqD,OAAR,EAAiBD,GAAjB,CAA3B;AACD,WAFwB,EAEtBH,GAFsB,CAAzB;AAIA,iBAAOC,gBAAP;AACD,SAbI,CAAP;AAcD;;AAED,SAAK,eAAL;AAAsB;AACpB,YAAMI,SAAS,GAAG;AAChBC,UAAAA,GAAG,EAAEpC,MAAM,CAACoC,GADI;AAEhBvC,UAAAA,WAAW,EAAE,IAFG;AAGhBwC,UAAAA,MAAM,kCACDrC,MAAM,CAACsC,IADN;AAEJC,YAAAA,UAAU,EAAE;AAFR;AAHU,SAAlB;AASA,eAAO1D,KAAK,CAAC6B,QAAN,CAAe,CAAC,cAAD,EAAiBV,MAAM,CAACoC,GAAxB,CAAf,EAA6C;AAAA,iBAAM,uBAAOD,SAAP,CAAN;AAAA,SAA7C,CAAP;AACD;;AACD,SAAK,yBAAL;AAAgC;AAC9B,YAAMA,UAAS,GAAG;AAChBC,UAAAA,GAAG,EAAEpC,MAAM,CAACoC,GADI;AAEhBvC,UAAAA,WAAW,EAAE,IAFG;AAGhB2C,UAAAA,QAAQ,EAAExC,MAAM,CAACyC,iBAHD;AAIhBJ,UAAAA,MAAM,kCACDrC,MAAM,CAACsC,IADN;AAEJC,YAAAA,UAAU,EAAE;AAFR;AAJU,SAAlB;;AAUA,YAAIvC,MAAM,CAACuB,wBAAX,EAAqC;AACnC,iBAAO1C,KAAK,CACT6B,QADI,CACK,CAAC,YAAD,EAAeV,MAAM,CAACoC,GAAtB,CADL,EACiC;AAAA,mBAAM,uBAAOD,UAAP,CAAN;AAAA,WADjC,EAEJzB,QAFI,CAEK,CAAC,cAAD,EAAiB,YAAjB,EAA+BV,MAAM,CAACoC,GAAtC,CAFL,EAEiD;AAAA,mBAAM,uBAAOD,UAAP,CAAN;AAAA,WAFjD,CAAP;AAGD;;AAED,eAAOtD,KAAK,CAAC6B,QAAN,CAAe,CAAC,YAAD,EAAeV,MAAM,CAACoC,GAAtB,CAAf,EAA2C;AAAA,iBAAM,uBAAOD,UAAP,CAAN;AAAA,SAA3C,CAAP;AACD;;AACD,SAAK,uBAAL;AAA8B;AAC5B;AACA,eAAOtD,KAAK,CACTwC,MADI,CACG,cADH,EACmB;AAAA,iBAAMxC,KAAK,CAACO,GAAN,CAAU,qBAAV,CAAN;AAAA,SADnB,EAEJiC,MAFI,CAEG,YAFH,EAEiB;AAAA,iBAAMxC,KAAK,CAACO,GAAN,CAAU,mBAAV,CAAN;AAAA,SAFjB,CAAP;AAGD;;AACD,SAAK,gBAAL;AAAuB;AAAA,qCAMjBY,MANiB,CAEnBE,cAFmB;AAAA,YAEDC,KAFC,0BAEDA,IAFC;AAAA,YAEQC,KAFR;AAAA,YAGnBC,UAHmB,GAMjBL,MANiB,CAGnBK,SAHmB;AAAA,YAInBC,UAJmB,GAMjBN,MANiB,CAInBM,SAJmB;AAAA,YAKnBoC,gBALmB,GAMjB1C,MANiB,CAKnB0C,gBALmB;;AAOrB,YAAIC,QAAQ,GAAG9D,KAAf;AAEA,YAAM+D,oBAAoB,GAAG,iBAAIF,gBAAJ,EAAsB,CAAC,MAAD,CAAtB,EAAgC,EAAhC,CAA7B;;AACA,YAAMlC,iBAAgB,GAAG,CAAC,WAAD,EAAc,aAAd,EAA6BC,QAA7B,CAAsCJ,UAAtC,IACrB,CAACA,UAAD,CADqB,GAErB,CAACA,UAAD,EAAYC,UAAZ,CAFJ;;AAIA,eAAOqC,QAAQ,CAACjC,QAAT,EAAmB,cAAnB,SAAsCF,iBAAtC,GAAwD,QAAxD,IAAmE,UAAAG,GAAG,EAAI;AAC/E,cAAIkC,6BAA6B,GAAG,IAApC;AACA,cAAIC,6BAA6B,GAAG,IAApC;AACA,cAAIC,kDAAkD,GAAG,IAAzD;AACA,cAAIC,yBAAyB,GAAG,IAAhC;AAEA,cAAMhE,MAAM,GAAG,2BACb2B,GAAG,CACAvB,GADH,CACO,YADP,EAEG6D,MAFH,GAGGjB,MAHH,CAGU,UAACC,GAAD,EAAMC,OAAN,EAAkB;AACxB,gBAAMgB,yBAAyB,GAAGhB,OAAO,KAAKU,oBAA9C;;AAEA,gBAAIM,yBAAJ,EAA+B;AAC7B,kBAAMpC,UAAU,GAAGjC,KAAK,CAACK,KAAN,EAAa,cAAb,SAAgCsB,iBAAhC,GAAkD,KAAlD,GAAnB;AACA,kBAAM2C,iBAAiB,GAAG,iBAAIT,gBAAJ,EAAsB,QAAtB,CAA1B;AACA,kBAAMU,uBAAuB,GAAGV,gBAAgB,CAAC9B,MAAjB,KAA4BR,KAAI,CAACQ,MAAjE;AACA,kBAAMyC,yBAAyB,GAAGjD,KAAI,CAACQ,MAAL,KAAgBE,UAAlD;AACA,kBAAMD,MAAM,GAAGT,KAAI,CAACS,MAApB;AACA,kBAAMyC,aAAa,GAAGZ,gBAAgB,CAAC7B,MAAvC;AACA,kBAAM0C,mBAAmB,GAAGb,gBAAgB,CAAC9B,MAAjB,KAA4BE,UAAxD;AACA,kBAAM0C,uBAAuB,GAAGd,gBAAgB,CAAC7B,MAAjB,KAA4BA,MAA5D;AACA,kBAAM4C,kDAAkD,GACtDL,uBAAuB,IACvB,CAACC,yBADD,IAEAE,mBAFA,IAGAJ,iBAJF;AAKA,kBAAMO,kDAAkD,GACtDF,uBAAuB,IACvBD,mBADA,IAEA,CAAC,QAAD,EAAW,SAAX,EAAsB9C,QAAtB,CAA+BI,MAA/B,CAFA,IAGAsC,iBAJF;AAKA,kBAAMQ,kDAAkD,GACtD,CAAClF,kBAAkB,CAACgC,QAAnB,CAA4B6C,aAA5B,CAAD,IACA,CAAC7E,kBAAkB,CAACgC,QAAnB,CAA4BI,MAA5B,CADD,IAEA0C,mBAFA,IAGAF,yBAHA,IAIAF,iBALF;AAMA,kBAAMS,kDAAkD,GACtDnF,kBAAkB,CAACgC,QAAnB,CAA4B6C,aAA5B,KACA,CAAC7E,kBAAkB,CAACgC,QAAnB,CAA4BI,MAA5B,CADD,IAEA0C,mBAFA,IAGAF,yBAHA,IAIAF,iBALF;AAMA,kBAAMU,kDAAkD,GACtDT,uBAAuB,IACvBC,yBADA,IAEA,CAAC5E,kBAAkB,CAACgC,QAAnB,CAA4BI,MAA5B,CAHH,CA/B6B,CAoC7B;;AACA,kBACE4C,kDAAkD,IAClDC,kDAFF,EAGE;AACAb,gBAAAA,6BAA6B,GAAGH,gBAAgB,CAACxB,eAAjD;AACD,eA1C4B,CA4C7B;;;AACA,kBACEyC,kDAAkD,IAClDC,kDADA,IAEAC,kDAHF,EAIE;AACAf,gBAAAA,6BAA6B,GAAGJ,gBAAgB,CAACxB,eAAjD;AACA6B,gBAAAA,kDAAkD,GAAG3C,KAAI,CAACc,eAA1D;AAEA8B,gBAAAA,yBAAyB,GAAG;AAC1BnC,kBAAAA,MAAM,EAAEnC,iBAAiB,CAAC0B,KAAI,CAACS,MAAN,CADC;AAE1BD,kBAAAA,MAAM,EAAER,KAAI,CAACQ,MAFa;AAG1BI,kBAAAA,MAAM,EAAEZ,KAAI,CAACY,MAHa;AAI1B;AACA;AACAC,kBAAAA,QAAQ,EAAEb,KAAI,CAACS,MAAL,KAAgB,YAAhB,GAA+B,CAACT,KAAI,CAACa,QAArC,GAAgD,IANhC;AAO1BC,kBAAAA,eAAe,EAAEf,KAPS;AAQ1BgB,kBAAAA,UAAU,EAAEf,KAAI,CAACgB,gBARS;AAS1BA,kBAAAA,gBAAgB,EAAEhB,KAAI,CAACe;AATG,iBAA5B,CAJA,CAgBA;;AACAc,gBAAAA,GAAG,CAAC9B,KAAD,CAAH,GAAY,uBAAOC,KAAP,CAAZ,CAjBA,CAmBA;AACA;AACA;;AACA,oBACEwD,kDAAkD,IAClDC,kDAFF,EAGE;AACA5B,kBAAAA,GAAG,CAACc,kDAAD,CAAH,GAA0D,uBACxDC,yBADwD,CAA1D;AAIAA,kBAAAA,yBAAyB,GAAG,IAA5B;AACAD,kBAAAA,kDAAkD,GAAG,IAArD;AACD;;AAED,uBAAOd,GAAP;AACD;;AAEDA,cAAAA,GAAG,CAAC9B,KAAD,CAAH,GAAY,uBAAOC,KAAP,CAAZ;AACD,aAvFD,MAuFO,IAAI8B,OAAO,KAAKY,6BAAhB,EAA+C;AACpDb,cAAAA,GAAG,CAACc,kDAAD,CAAH,GAA0D,uBACxDC,yBADwD,CAA1D;AAGD,aAJM,MAIA;AACLf,cAAAA,GAAG,CAACC,OAAD,CAAH,GAAevB,GAAG,CAACzB,KAAJ,CAAU,CAAC,YAAD,EAAegD,OAAf,CAAV,CAAf;AACD;;AAED,mBAAOD,GAAP;AACD,WAtGH,EAsGK,EAtGL,CADa,CAAf;AA0GA,cAAI6B,UAAJ,CAhH+E,CAkH/E;;AACA,cAAIjB,6BAA6B,KAAK,IAAtC,EAA4C;AAC1CiB,YAAAA,UAAU,GAAG9E,MAAM,CAAC+E,MAAP,CAAclB,6BAAd,CAAb;AACD,WAFD,MAEO;AACLiB,YAAAA,UAAU,GAAG9E,MAAb;AACD;;AAED,iBAAO2B,GAAG,CAACnB,GAAJ,CAAQ,YAAR,EAAsBsE,UAAtB,CAAP;AACD,SA1HM,CAAP;AA2HD;;AAED,SAAK,oBAAL;AAA2B;AACzB,eAAOjF,KAAK,CACTwC,MADI,CACG,YADH,EACiB;AAAA,iBAAM,uBAAOrB,MAAM,CAAChC,UAAd,CAAN;AAAA,SADjB,EAEJqD,MAFI,CAEG,mBAFH,EAEwB;AAAA,iBAAM,uBAAOrB,MAAM,CAAChC,UAAd,CAAN;AAAA,SAFxB,EAGJqD,MAHI,CAGG,qBAHH,EAG0B;AAAA,iBAAM,uBAAOrB,MAAM,CAAC/B,YAAd,CAAN;AAAA,SAH1B,EAIJoD,MAJI,CAIG,cAJH,EAImB;AAAA,iBAAM,uBAAOrB,MAAM,CAAC/B,YAAd,CAAN;AAAA,SAJnB,EAKJoD,MALI,CAKG,eALH,EAKoB;AAAA,iBAAM,uBAAOrB,MAAM,CAAC1B,aAAd,CAAN;AAAA,SALpB,EAOJ+C,MAPI,CAOG,WAPH,EAOgB;AAAA,iBAAM,KAAN;AAAA,SAPhB,CAAP;AAQD;;AACD,SAAK,eAAL;AACE,aAAOtD,YAAP;;AACF,SAAK,uCAAL;AAA8C;AAAA,YACpCiG,qBADoC,GACIhE,MADJ,CACpCgE,qBADoC;AAAA,YACbpE,YADa,GACII,MADJ,CACbJ,YADa;AAG5C,eAAOf,KAAK,CAACoF,QAAN,CAAe,CACpB,cADoB,EAEpB,YAFoB,EAGpBrE,YAHoB,EAIpB,QAJoB,EAKpB,YALoB,EAMpBoE,qBANoB,CAAf,CAAP;AAQD;;AACD,SAAK,oCAAL;AACE,aAAOnF,KAAK,CAACoF,QAAN,CAAe,CACpB,cADoB,EAEpB,aAFoB,EAGpB,QAHoB,EAIpB,YAJoB,EAKpBjE,MAAM,CAACkE,MALa,EAMpB,YANoB,EAOpBlE,MAAM,CAACmE,sBAPa,CAAf,CAAP;;AASF,SAAK,cAAL;AAAqB;AAAA,YACXC,WADW,GAC4BpE,MAD5B,CACXoE,WADW;AAAA,YACEJ,sBADF,GAC4BhE,MAD5B,CACEgE,qBADF;AAEnB,YAAMK,gBAAgB,GAAG,CAAC,cAAD,EAAiBD,WAAjB,EAA8B,QAA9B,EAAwC,YAAxC,CAAzB;AACA,YAAME,uBAAuB,aAAOD,gBAAP,GAAyBL,sBAAzB,EAA7B;AAEA,YAAMO,qBAAqB,GAAG1F,KAAK,CAACK,KAAN,CAAYoF,uBAAZ,CAA9B;AAEA,YAAME,2BAA2B,GAAGD,qBAAqB,CAACnF,GAAtB,CAA0B,QAA1B,MAAwCG,SAA5E,CAPmB,CAQnB;AACA;;AACA,YAAMkF,8CAA8C,GAAGL,WAAW,KAAK,aAAvE;;AAEA,YAAII,2BAA2B,IAAIC,8CAAnC,EAAmF;AAAA,sCACrCF,qBAAqB,CAAC7E,IAAtB,EADqC;AAAA,cACzEkB,MADyE,yBACzEA,MADyE;AAAA,cACjEC,MADiE,yBACjEA,MADiE;AAAA,cACzDK,eADyD,yBACzDA,eADyD;;AAEjF,cAAMkB,GAAG,GAAGvD,KAAK,CAACK,KAAN,CAAY,CAAC,cAAD,EAAiB,aAAjB,EAAgC,KAAhC,CAAZ,CAAZ;AACA,cAAMwF,6BAA6B,GACjC9D,MAAM,KAAKwB,GAAX,IAAkB,CAAC3D,kBAAkB,CAACgC,QAAnB,CAA4BI,MAA5B,CADrB;;AAGA,cAAI6D,6BAAJ,EAAmC;AACjC,mBAAO7F,KAAK,CACToF,QADI,CACKK,uBADL,EAEJL,QAFI,WAESI,gBAFT,GAE2BnD,eAF3B,GAAP;AAGD;AACF;;AAED,eAAOrC,KAAK,CAACoF,QAAN,CAAeK,uBAAf,EAAwC5D,QAAxC,WAAqD2D,gBAArD,GAAwE,UAAA9B,UAAU,EAAI;AAC3F,iBAAOA,UAAU,CAACU,MAAX,GAAoBjB,MAApB,CAA2B,UAACC,GAAD,EAAMC,OAAN,EAAkB;AAClD,gBAAID,GAAG,CAAC/C,KAAJ,CAAU,CAACgD,OAAD,EAAU,aAAV,CAAV,MAAwC8B,sBAA5C,EAAmE;AACjE,qBAAO/B,GAAG,CAACgC,QAAJ,CAAa,CAAC/B,OAAD,EAAU,aAAV,CAAb,CAAP;AACD;;AAED,mBAAOD,GAAP;AACD,WANM,EAMJM,UANI,CAAP;AAOD,SARM,CAAP;AASD;;AACD,SAAK,mBAAL;AAA0B;AACxB,YAAII,SAAQ,GAAG9D,KAAK,CACjBwC,MADY,CACL,yBADK,EACsB;AAAA,iBAAM,KAAN;AAAA,SADtB,EAEZA,MAFY,CAEL,aAFK,EAEU;AAAA,iBAAM,uBAAOrB,MAAM,CAAC2E,WAAd,CAAN;AAAA,SAFV,EAGZtD,MAHY,CAGL,cAHK,EAGW;AAAA,iBAAM,uBAAOrB,MAAM,CAAC2E,WAAd,CAAN;AAAA,SAHX,CAAf,CADwB,CAMxB;AACA;;;AACA,YAAI,CAAC3E,MAAM,CAAC4E,oBAAZ,EAAkC;AAChCjC,UAAAA,SAAQ,GAAGA,SAAQ,CAChBtB,MADQ,CACD,YADC,EACa;AAAA,mBAAMxC,KAAK,CAACO,GAAN,CAAU,mBAAV,CAAN;AAAA,WADb,EAERiC,MAFQ,CAED,cAFC,EAEe;AAAA,mBAAMxC,KAAK,CAACO,GAAN,CAAU,qBAAV,CAAN;AAAA,WAFf,CAAX;AAGD;;AAED,eAAOuD,SAAP;AACD;;AACD,SAAK,eAAL;AAAsB;AAAA,2BAKhB3C,MALgB,CAElBsC,IAFkB;AAAA,YAEVnC,MAFU,gBAEVA,IAFU;AAAA,YAEJ0E,cAFI,gBAEJA,cAFI;AAAA,YAEYrC,QAFZ,gBAEYA,QAFZ;AAAA,YAEsBsC,IAFtB,gBAEsBA,IAFtB;AAAA,YAE4BC,IAF5B,gBAE4BA,IAF5B;AAAA,YAGlBC,UAHkB,GAKhBhF,MALgB,CAGlBgF,UAHkB;AAAA,YAIlB5C,IAJkB,GAKhBpC,MALgB,CAIlBoC,GAJkB;;AAOpB,YAAIO,UAAQ,GAAG9D,KAAK,CAAC6B,QAAN,CAAe,CAAC,cAAD,EAAiBsE,UAAjB,CAAf,EAA6C,UAAArE,GAAG,EAAI;AACjE,cAAImD,UAAU,GAAGnD,GAAG,CACjBD,QADc,CACL,CAAC,QAAD,EAAW,MAAX,CADK,EACe;AAAA,mBAAMP,MAAN;AAAA,WADf,EAEdO,QAFc,CAEL,CAAC,QAAD,EAAW,gBAAX,CAFK,EAEyB;AAAA,mBAAMmE,cAAN;AAAA,WAFzB,CAAjB;;AAIA,cAAI7E,MAAM,CAACgF,UAAP,KAAsB,WAA1B,EAAuC;AACrClB,YAAAA,UAAU,GAAGA,UAAU,CACpBzC,MADU,CACH,UADG,EACS;AAAA,qBAAMmB,QAAN;AAAA,aADT,EAEV9B,QAFU,CAED,CAAC,QAAD,EAAW,MAAX,CAFC,EAEmB;AAAA,qBAAMoE,IAAN;AAAA,aAFnB,CAAb;AAGD;;AACD,cAAI9E,MAAM,CAACgF,UAAP,KAAsB,aAA1B,EAAyC;AACvClB,YAAAA,UAAU,GAAGA,UAAU,CAACpD,QAAX,CAAoB,CAAC,QAAD,EAAW,MAAX,CAApB,EAAwC;AAAA,qBAAMqE,IAAN;AAAA,aAAxC,CAAb;AACD;;AAED,iBAAOjB,UAAP;AACD,SAfc,CAAf;;AAiBA,YAAIkB,UAAU,KAAK,WAAnB,EAAgC;AAC9BrC,UAAAA,UAAQ,GAAGA,UAAQ,CAACjC,QAAT,CAAkB,CAAC,YAAD,CAAlB,EAAkC,UAAAC,GAAG,EAAI;AAClD,mBAAOA,GAAG,CAACU,MAAJ,CAAWe,IAAX,EAAgB;AAAA,qBAAMO,UAAQ,CAACzD,KAAT,CAAe,CAAC,cAAD,EAAiB,WAAjB,CAAf,CAAN;AAAA,aAAhB,CAAP;AACD,WAFU,CAAX;AAGD;;AAED,eAAOyD,UAAP;AACD;;AACD;AACE,aAAO9D,KAAP;AAlYJ;AAoYD,CArYD;;eAuYekB,O","sourcesContent":["import { fromJS, OrderedMap } from 'immutable';\nimport { get, has } from 'lodash';\nimport makeUnique from '../../utils/makeUnique';\nimport retrieveComponentsFromSchema from './utils/retrieveComponentsFromSchema';\n\nconst initialState = fromJS({\n  components: {},\n  contentTypes: {},\n  initialComponents: {},\n  initialContentTypes: {},\n  initialData: {},\n  modifiedData: {},\n  reservedNames: {},\n  isLoading: true,\n  isLoadingForDataToBeSet: true,\n});\n\nconst ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];\n\nconst getOppositeNature = originalNature => {\n  if (originalNature === 'manyToOne') {\n    return 'oneToMany';\n  }\n\n  if (originalNature === 'oneToMany') {\n    return 'manyToOne';\n  }\n\n  return originalNature;\n};\n\nconst addComponentsToState = (state, componentToAddUid, objToUpdate) => {\n  let newObj = objToUpdate;\n  const componentToAdd = state.getIn(['components', componentToAddUid]);\n  const isTemporaryComponent = componentToAdd.get('isTemporary');\n  const componentToAddSchema = componentToAdd.getIn(['schema', 'attributes']);\n  const hasComponentAlreadyBeenAdded =\n    state.getIn(['modifiedData', 'components', componentToAddUid]) !== undefined;\n\n  // created components are already in the modifiedData.components\n  // We don't add them because all modifications will be lost\n  if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {\n    return newObj;\n  }\n\n  // Add the added components to the modifiedData.compontnes\n  newObj = newObj.set(componentToAddUid, componentToAdd);\n  const nestedComponents = retrieveComponentsFromSchema(\n    componentToAddSchema.toJS(),\n    state.get('components').toJS()\n  );\n\n  // We need to add the nested components to the modifiedData.components as well\n  nestedComponents.forEach(componentUid => {\n    const isTemporary = state.getIn(['components', componentUid, 'isTemporary']) || false;\n    const hasNestedComponentAlreadyBeenAdded =\n      state.getIn(['modifiedData', 'components', componentUid]) !== undefined;\n\n    // Same logic here otherwise we will lose the modifications added to the components\n    if (!isTemporary && !hasNestedComponentAlreadyBeenAdded) {\n      newObj = newObj.set(componentUid, state.getIn(['components', componentUid]));\n    }\n  });\n\n  return newObj;\n};\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_ATTRIBUTE': {\n      const {\n        attributeToSet: { name, ...rest },\n        forTarget,\n        targetUid,\n      } = action;\n      delete rest.createComponent;\n\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      return state\n        .updateIn(['modifiedData', ...pathToDataToEdit, 'schema', 'attributes', name], () => {\n          return fromJS(rest);\n        })\n        .updateIn(['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'], obj => {\n          const type = get(rest, 'type', 'relation');\n          const target = get(rest, 'target', null);\n          const nature = get(rest, 'nature', null);\n          const currentUid = state.getIn(['modifiedData', ...pathToDataToEdit, 'uid']);\n\n          // When the user in creating a relation with the same content type we need to create another attribute\n          // that is the opposite of the created one\n          if (\n            type === 'relation' &&\n            nature !== 'oneWay' &&\n            nature !== 'manyWay' &&\n            target === currentUid\n          ) {\n            const oppositeAttribute = {\n              nature: getOppositeNature(nature),\n              target,\n              unique: rest.unique,\n              // Leave this if we allow the required on the relation\n              // required: rest.required,\n              dominant: nature === 'manyToMany' ? !rest.dominant : null,\n              targetAttribute: name,\n              columnName: rest.targetColumnName,\n              targetColumnName: rest.columnName,\n            };\n\n            return obj.update(rest.targetAttribute, () => {\n              return fromJS(oppositeAttribute);\n            });\n          }\n\n          return obj;\n        })\n        .updateIn(['modifiedData', 'components'], existingCompos => {\n          if (action.shouldAddComponentToData) {\n            return addComponentsToState(state, rest.component, existingCompos);\n          }\n\n          return existingCompos;\n        });\n    }\n    case 'ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE': {\n      const { dynamicZoneTarget, componentsToAdd } = action;\n\n      return state.updateIn(\n        ['modifiedData', 'contentType', 'schema', 'attributes', dynamicZoneTarget, 'components'],\n        list => {\n          return list.concat(componentsToAdd);\n        }\n      );\n    }\n    case 'CANCEL_CHANGES': {\n      return state\n        .update('modifiedData', () => state.get('initialData'))\n        .update('components', () => state.get('initialComponents'));\n    }\n    case 'CHANGE_DYNAMIC_ZONE_COMPONENTS': {\n      const { dynamicZoneTarget, newComponents } = action;\n\n      return state\n        .updateIn(\n          ['modifiedData', 'contentType', 'schema', 'attributes', dynamicZoneTarget, 'components'],\n          list => {\n            return fromJS(makeUnique([...list.toJS(), ...newComponents]));\n          }\n        )\n        .updateIn(['modifiedData', 'components'], old => {\n          const componentsSchema = newComponents.reduce((acc, current) => {\n            return addComponentsToState(state, current, acc);\n          }, old);\n\n          return componentsSchema;\n        });\n    }\n\n    case 'CREATE_SCHEMA': {\n      const newSchema = {\n        uid: action.uid,\n        isTemporary: true,\n        schema: {\n          ...action.data,\n          attributes: {},\n        },\n      };\n\n      return state.updateIn(['contentTypes', action.uid], () => fromJS(newSchema));\n    }\n    case 'CREATE_COMPONENT_SCHEMA': {\n      const newSchema = {\n        uid: action.uid,\n        isTemporary: true,\n        category: action.componentCategory,\n        schema: {\n          ...action.data,\n          attributes: {},\n        },\n      };\n\n      if (action.shouldAddComponentToData) {\n        return state\n          .updateIn(['components', action.uid], () => fromJS(newSchema))\n          .updateIn(['modifiedData', 'components', action.uid], () => fromJS(newSchema));\n      }\n\n      return state.updateIn(['components', action.uid], () => fromJS(newSchema));\n    }\n    case 'DELETE_NOT_SAVED_TYPE': {\n      // Doing so will also reset the modified and the initial data\n      return state\n        .update('contentTypes', () => state.get('initialContentTypes'))\n        .update('components', () => state.get('initialComponents'));\n    }\n    case 'EDIT_ATTRIBUTE': {\n      const {\n        attributeToSet: { name, ...rest },\n        forTarget,\n        targetUid,\n        initialAttribute,\n      } = action;\n      let newState = state;\n\n      const initialAttributeName = get(initialAttribute, ['name'], '');\n      const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)\n        ? [forTarget]\n        : [forTarget, targetUid];\n\n      return newState.updateIn(['modifiedData', ...pathToDataToEdit, 'schema'], obj => {\n        let oppositeAttributeNameToRemove = null;\n        let oppositeAttributeNameToUpdate = null;\n        let oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n        let oppositeAttributeToCreate = null;\n\n        const newObj = OrderedMap(\n          obj\n            .get('attributes')\n            .keySeq()\n            .reduce((acc, current) => {\n              const isEditingCurrentAttribute = current === initialAttributeName;\n\n              if (isEditingCurrentAttribute) {\n                const currentUid = state.getIn(['modifiedData', ...pathToDataToEdit, 'uid']);\n                const isEditingRelation = has(initialAttribute, 'nature');\n                const didChangeTargetRelation = initialAttribute.target !== rest.target;\n                const didCreateInternalRelation = rest.target === currentUid;\n                const nature = rest.nature;\n                const initialNature = initialAttribute.nature;\n                const hadInternalRelation = initialAttribute.target === currentUid;\n                const didChangeRelationNature = initialAttribute.nature !== nature;\n                const shouldRemoveOppositeAttributeBecauseOfTargetChange =\n                  didChangeTargetRelation &&\n                  !didCreateInternalRelation &&\n                  hadInternalRelation &&\n                  isEditingRelation;\n                const shouldRemoveOppositeAttributeBecauseOfNatureChange =\n                  didChangeRelationNature &&\n                  hadInternalRelation &&\n                  ['oneWay', 'manyWay'].includes(nature) &&\n                  isEditingRelation;\n                const shouldUpdateOppositeAttributeBecauseOfNatureChange =\n                  !ONE_SIDE_RELATIONS.includes(initialNature) &&\n                  !ONE_SIDE_RELATIONS.includes(nature) &&\n                  hadInternalRelation &&\n                  didCreateInternalRelation &&\n                  isEditingRelation;\n                const shouldCreateOppositeAttributeBecauseOfNatureChange =\n                  ONE_SIDE_RELATIONS.includes(initialNature) &&\n                  !ONE_SIDE_RELATIONS.includes(nature) &&\n                  hadInternalRelation &&\n                  didCreateInternalRelation &&\n                  isEditingRelation;\n                const shouldCreateOppositeAttributeBecauseOfTargetChange =\n                  didChangeTargetRelation &&\n                  didCreateInternalRelation &&\n                  !ONE_SIDE_RELATIONS.includes(nature);\n\n                // Update the opposite attribute name so it is removed at the end of the loop\n                if (\n                  shouldRemoveOppositeAttributeBecauseOfTargetChange ||\n                  shouldRemoveOppositeAttributeBecauseOfNatureChange\n                ) {\n                  oppositeAttributeNameToRemove = initialAttribute.targetAttribute;\n                }\n\n                // Set the opposite attribute that will be updated when the loop attribute matches the name\n                if (\n                  shouldUpdateOppositeAttributeBecauseOfNatureChange ||\n                  shouldCreateOppositeAttributeBecauseOfNatureChange ||\n                  shouldCreateOppositeAttributeBecauseOfTargetChange\n                ) {\n                  oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;\n                  oppositeAttributeNameToCreateBecauseOfNatureChange = rest.targetAttribute;\n\n                  oppositeAttributeToCreate = {\n                    nature: getOppositeNature(rest.nature),\n                    target: rest.target,\n                    unique: rest.unique,\n                    // Leave this if we allow the required on the relation\n                    // required: rest.required,\n                    dominant: rest.nature === 'manyToMany' ? !rest.dominant : null,\n                    targetAttribute: name,\n                    columnName: rest.targetColumnName,\n                    targetColumnName: rest.columnName,\n                  };\n\n                  // First update the current attribute with the value\n                  acc[name] = fromJS(rest);\n\n                  // Then (if needed) create the opposite attribute the case is changing the relation from\n                  // We do it here so keep the order of the attributes\n                  // oneWay || manyWay to something another relation\n                  if (\n                    shouldCreateOppositeAttributeBecauseOfNatureChange ||\n                    shouldCreateOppositeAttributeBecauseOfTargetChange\n                  ) {\n                    acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = fromJS(\n                      oppositeAttributeToCreate\n                    );\n\n                    oppositeAttributeToCreate = null;\n                    oppositeAttributeNameToCreateBecauseOfNatureChange = null;\n                  }\n\n                  return acc;\n                }\n\n                acc[name] = fromJS(rest);\n              } else if (current === oppositeAttributeNameToUpdate) {\n                acc[oppositeAttributeNameToCreateBecauseOfNatureChange] = fromJS(\n                  oppositeAttributeToCreate\n                );\n              } else {\n                acc[current] = obj.getIn(['attributes', current]);\n              }\n\n              return acc;\n            }, {})\n        );\n\n        let updatedObj;\n\n        // Remove the opposite attribute\n        if (oppositeAttributeNameToRemove !== null) {\n          updatedObj = newObj.remove(oppositeAttributeNameToRemove);\n        } else {\n          updatedObj = newObj;\n        }\n\n        return obj.set('attributes', updatedObj);\n      });\n    }\n\n    case 'GET_DATA_SUCCEEDED': {\n      return state\n        .update('components', () => fromJS(action.components))\n        .update('initialComponents', () => fromJS(action.components))\n        .update('initialContentTypes', () => fromJS(action.contentTypes))\n        .update('contentTypes', () => fromJS(action.contentTypes))\n        .update('reservedNames', () => fromJS(action.reservedNames))\n\n        .update('isLoading', () => false);\n    }\n    case 'RELOAD_PLUGIN':\n      return initialState;\n    case 'REMOVE_FIELD_FROM_DISPLAYED_COMPONENT': {\n      const { attributeToRemoveName, componentUid } = action;\n\n      return state.removeIn([\n        'modifiedData',\n        'components',\n        componentUid,\n        'schema',\n        'attributes',\n        attributeToRemoveName,\n      ]);\n    }\n    case 'REMOVE_COMPONENT_FROM_DYNAMIC_ZONE':\n      return state.removeIn([\n        'modifiedData',\n        'contentType',\n        'schema',\n        'attributes',\n        action.dzName,\n        'components',\n        action.componentToRemoveIndex,\n      ]);\n    case 'REMOVE_FIELD': {\n      const { mainDataKey, attributeToRemoveName } = action;\n      const pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];\n      const pathToAttributeToRemove = [...pathToAttributes, attributeToRemoveName];\n\n      const attributeToRemoveData = state.getIn(pathToAttributeToRemove);\n\n      const isRemovingRelationAttribute = attributeToRemoveData.get('nature') !== undefined;\n      // Only content types can have relations with themselves since\n      // components can only have oneWay or manyWay relations\n      const canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';\n\n      if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {\n        const { target, nature, targetAttribute } = attributeToRemoveData.toJS();\n        const uid = state.getIn(['modifiedData', 'contentType', 'uid']);\n        const shouldRemoveOppositeAttribute =\n          target === uid && !ONE_SIDE_RELATIONS.includes(nature);\n\n        if (shouldRemoveOppositeAttribute) {\n          return state\n            .removeIn(pathToAttributeToRemove)\n            .removeIn([...pathToAttributes, targetAttribute]);\n        }\n      }\n\n      return state.removeIn(pathToAttributeToRemove).updateIn([...pathToAttributes], attributes => {\n        return attributes.keySeq().reduce((acc, current) => {\n          if (acc.getIn([current, 'targetField']) === attributeToRemoveName) {\n            return acc.removeIn([current, 'targetField']);\n          }\n\n          return acc;\n        }, attributes);\n      });\n    }\n    case 'SET_MODIFIED_DATA': {\n      let newState = state\n        .update('isLoadingForDataToBeSet', () => false)\n        .update('initialData', () => fromJS(action.schemaToSet))\n        .update('modifiedData', () => fromJS(action.schemaToSet));\n\n      // Reset the state with the initial data\n      // All created components and content types will be lost\n      if (!action.hasJustCreatedSchema) {\n        newState = newState\n          .update('components', () => state.get('initialComponents'))\n          .update('contentTypes', () => state.get('initialContentTypes'));\n      }\n\n      return newState;\n    }\n    case 'UPDATE_SCHEMA': {\n      const {\n        data: { name, collectionName, category, icon, kind },\n        schemaType,\n        uid,\n      } = action;\n\n      let newState = state.updateIn(['modifiedData', schemaType], obj => {\n        let updatedObj = obj\n          .updateIn(['schema', 'name'], () => name)\n          .updateIn(['schema', 'collectionName'], () => collectionName);\n\n        if (action.schemaType === 'component') {\n          updatedObj = updatedObj\n            .update('category', () => category)\n            .updateIn(['schema', 'icon'], () => icon);\n        }\n        if (action.schemaType === 'contentType') {\n          updatedObj = updatedObj.updateIn(['schema', 'kind'], () => kind);\n        }\n\n        return updatedObj;\n      });\n\n      if (schemaType === 'component') {\n        newState = newState.updateIn(['components'], obj => {\n          return obj.update(uid, () => newState.getIn(['modifiedData', 'component']));\n        });\n      }\n\n      return newState;\n    }\n    default:\n      return state;\n  }\n};\n\nexport default reducer;\nexport { addComponentsToState, initialState };\n"]},"metadata":{},"sourceType":"script"}